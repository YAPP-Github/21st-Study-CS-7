# **Transaction**

<aside>
💡  <b>데이터베이스의 상태를 변화시키는 논리적인 작업</b>이다. 트랜잭션이 안전하게 수행된다는 것을 보장하기 위해 ACID 성질이 정의되어 있다.

</aside>

## 필요성

DB 서버에 여러 클라이언트가 동시에 엑세스하거나, 응용 프로그램이 갱신을 처리하는 과정에서 중단되는 경우 등, 데이터 부정합을 방지하고자 할 때 사용한다.

트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적인 단위로, 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위이다.

트랜잭션이 안전하게 수행되기 위해서는 ACID 조건을 충족해야 한다.

## 스프링 내에서 트랜잭션

### JPA 동작 방식

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/710281ab-ee34-4760-afd4-01f76144e0b9/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221222%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221222T044907Z&X-Amz-Expires=86400&X-Amz-Signature=ff74a6eb37a5f99983b5f384dceaa79ed2e537b7e283395fa988fd6b984b612b&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22Untitled.png%22&x-id=GetObject)

JPA 에는 Persistence 클래스가 있다. META-INF/persistence.xml 에 있는 설정 정보를 읽어서, EntityManagerFactory 클래스를 생성한다.

필요할 때마다 EntityManager 를 생성해서 돌린다.

Persistence.createEntityManagerFactory 를 하는 순간, DB 연결이 된다.

emf는 애플리케이션 로딩 시점에 딱 하나만 만들어 둬야 한다. 

요청이 와서 DB 커넥션을 얻어서 쿼리를 날리고 종료되는 일괄적인 단위를 해야할 때마다 ,**EntityManager**를 만들어 줘야 한다. = **실제 DB에 저장하는 트랜잭션 단위** 

EM 생성은, DB 커넥션을 하나 받은 것과 마찬가지다. 그래서 그냥 작업하는 게 아니라, em.getTransaction()으로 트랜잭션을 가져온 후, begin() 으로 트랜잭션을 실행해주고, 로직이 종료된 후 commit() 으로 트랜잭션을 커밋해줘야 한다.

당연히 데이터가 변경되는 모든 작업들은 트랜잭션 내부에서 이뤄져야 하고, 정상적인 작업이면 트랜잭션 커밋, 문제가 있는 작업이면 롤백 후에 em을 close 해주는 작업까지 해야 한다. EM이 내부적으로 DB 커넥션을 물고 동작하기 때문에 꼭 사용 후에는 닫아줘야 한다. 전체 애플리케이션이 끝나면 EMF 도 닫아야 한다. = 모든 작업을 스프링이 해준다. 

### 스프링 트랜잭션 옵션

## ACID

데이터 베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어이다. 

짐 그레이가 70년대 말에 신뢰할 수 있는 트랜잭션 시스템의 특성들을 정의하였고, 83년에 안드레아스 로이테르와 테오 헤르데르가 ACID라는 용어를 만들면서 이를 기술했다.

데이터베이스에서 데이터에 대한 하나의 논리적인 실행 단계를 트랜잭션이라고 한다. 

### 원자성 (Atomicity)

하나의 트랜잭션은 더이상 쪼갤 수 없는 최소한의 작업 단위이다. 트랜잭션이 데이터베이스에 모두 반영되던지, 아니면 아무것도 반영되지 않아야 한다.

트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장한다. 하나라도 에러가 발생하면 트랜잭션 내의 모든 작업이 롤백 되어야 한다.

원자성이 없다면, 오작동했을 때 원인을 찾기 힘들고, 어디서부터 이어서 진행해야하는지 헷갈린다.

보장 방법

수행 중인 트랜잭션에 의해 변경된 내역(**데이터베이스 테이블**)을 유지하면서, 이전 커밋된 상태를 임시 영역(**롤백 세그먼트**)에 따로 저장한다. 
만약 수행 중인 트랜잭션에서 오류가 발생하면, 현재 내역을 날리고 임시 영역에 저장했던 커밋된 상태로 롤백한다.

트랜잭션이 너무 길어지면 확실히 오류가 나지 않는 부분도 롤백 시켜야하는데, 이를 위해 확실히 오류가 나지 않는 부분에 대해 **세이브 포인트**를 지정할 수 있다.

### 일관성 (Consistency)

트랜잭션이 완료된 결과값은 항상 일관된 데이터베이스 상태를 유지해야 한다. 트랜잭션이 진행되는 동안 데이터베이스가 변경되더라도, 업데이트된 데이터베이스가 아니라 처음 트랜잭션 진행을 위해 참조한 데이터베이스로 트랜잭션이 진행된다. 

트랜잭션이 실행을 성공적으로 완료하면, 언제나 일관성있는 데이터베이스 상태로 유지하는 것을 의미하며, 오류 없는 유효한 데이터만 저장되어야 한다.

일관성으로 인해 각 사용자가 일관성 있는 데이터를 볼 수 있다.

보장 방법

트랜잭션에서의 일관성은 데이터 모델의 모든 제약 조건을 만족하는 것으로 보장된다. 

예를 들어 A 테이블의 pk가 B 테이블의 fk로 존재할 때, A 테이블에서 pk의 제약조건이 변경되면 B 테이블에서 fk의 제약 조건도 변경되어야 한다. 
트랜잭션은 이같은 어떤 이벤트와 조건이 발생했을 때, 트리거를 통해 보장한다. 
트리거란 데이터베이스 시스템이 자동적으로 수행할 동작을 명시할 때 사용되며, 어떤 행위의 시작을 알려준다. 

### 독립성 (Isolation)

하나의 트랜잭션 수행 시 다른 트랜잭션의 작업에 끼어들지 못하며, 서로 간섭할 수 없다. 즉, 트랜잭션 도중 변경된 데이터는 해당 트랜잭션이 완료되기 전까지는 다른 트랜잭션에 의해 참조될 수 없다.

트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하고, 트랜잭션 중 변경된 내용이 트랜잭션 완료 전까지 다른 트랜잭션에 영향을 미쳐서는 안된다. 

독립성이 없으면 트랜잭션이 원래 상태로 돌아갈 수 없다. 

보장 방법

DBMS의 병행 제어 모듈이 트랜잭션의 독립성을 보장한다. OS의 세마포어와 비슷하게, lock & excute unlock을 통해 독립성을 보장할 수 있다.

트랜잭션에서는 데이터를 읽을 때, 여러 트랜잭션이 읽도록 허용해주는 공유 록(shared lock)을 한다. (쓰기는 허용되지 않는다.)
데이터를 쓸 때는 다른 트랜잭션이 읽거나 쓸 수 없도록 하는 베타 록(exclusive lock)을 사용한다. 
모든 읽기 쓰기 작업이 끝나면 unlock을 통해 다른 트랜잭션이 lock을 할 수 있도록 데이터에 대한 잠금을 풀어준다. 

### 지속성 (Durability)

트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. 트랜잭션이 정상적으로 완료도니 경우에는 버퍼의 내용을 하드 디스크(데이터베이스)에 확실히 기록해야하며, 부분 완료(Partial Commit)된 경우에는 작업을 취소(Aborted) 해야 한다. 

트랜잭션이 완료된 경우 시스템 오류가 나더라도 커밋한 상태로 반영된 데이터가 유실되지 않고 유지되어야 한다. 
일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미한다. 
